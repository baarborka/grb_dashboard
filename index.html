<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRB Simulation & Analysis Lab</title>
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { font-family: 'Inter', system-ui, -apple-system, sans-serif; background-color: #f3f4f6; }
        /* Custom scrollbar for sidebar */
        aside::-webkit-scrollbar { width: 6px; }
        aside::-webkit-scrollbar-thumb { background-color: #d1d5db; border-radius: 3px; }
        .input-group label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600; color: #4b5563; }
        .input-group input, .input-group select, .input-group textarea { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; transition: border-color 0.15s; }
        .input-group input:focus, .input-group textarea:focus { border-color: #3b82f6; outline: none; ring: 2px solid #3b82f6; }
        .btn { transition: all 0.2s; }
        .btn:active { transform: scale(0.98); }
        .tab-btn.active { border-bottom: 2px solid #2563eb; color: #2563eb; background-color: #eff6ff; }
        .loader { border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="flex h-screen overflow-hidden text-gray-800">

    <!-- SIDEBAR: PARAMETERS -->
    <aside class="w-96 bg-white border-r border-gray-200 flex flex-col h-full shadow-lg z-10">
        <div class="p-5 border-b border-gray-100">
            <h1 class="text-xl font-extrabold text-blue-600 flex items-center gap-2">
                <i class="fa-solid fa-burst"></i> GRB Analysis Lab
            </h1>
            <p class="text-xs text-gray-400 mt-1">Full Physics Engine</p>
        </div>

        <div class="flex-1 overflow-y-auto p-5 space-y-6">
            
            <!-- Section: Band Function -->
            <div>
                <h3 class="text-xs font-bold text-gray-900 border-b pb-1 mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-atom text-blue-500"></i> Band Function
                </h3>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div class="input-group">
                        <label>Alpha</label>
                        <input type="number" id="alpha" value="-0.64" step="0.01">
                    </div>
                    <div class="input-group">
                        <label>Beta</label>
                        <input type="number" id="beta" value="-2.63" step="0.01">
                    </div>
                </div>
                <div class="input-group">
                    <label>E_peak (keV)</label>
                    <input type="number" id="e_peak" value="3038" step="10">
                </div>
            </div>

            <!-- Section: Power Law -->
            <div>
                <h3 class="text-xs font-bold text-gray-900 border-b pb-1 mb-3 flex items-center gap-2">
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="include_pl" class="w-3 h-3 text-blue-600 rounded">
                        <span>Power Law</span>
                    </div>
                </h3>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div class="input-group">
                        <label>Gamma</label>
                        <input type="number" id="gamma" value="1.7" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>K_pl (1e-8)</label>
                        <!-- Value 0.058 * 1e-8 = 5.8e-10 -->
                        <input type="number" id="k_pl" value="0.058" step="0.001">
                    </div>
                </div>
                <div class="input-group">
                    <label>E_cut (keV)</label>
                    <input type="number" id="e_cut" value="1400000">
                </div>
            </div>

            <!-- Section: Temporal -->
            <div>
                <h3 class="text-xs font-bold text-gray-900 border-b pb-1 mb-3 flex items-center gap-2">
                    <i class="fa-regular fa-clock text-green-500"></i> Pulse & Time
                </h3>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div class="input-group">
                        <label>Rise Index</label>
                        <input type="number" id="rise_index" value="25" step="1.0">
                    </div>
                    <div class="input-group">
                        <label>Decay Index</label>
                        <input type="number" id="decay_index" value="-0.2" step="0.1">
                    </div>
                </div>
                <div class="input-group mb-3">
                    <label>Lag Factor (Time Shift)</label>
                    <!-- T_peak_min=0.7, Max=0.75, so Lag=0.05 -->
                    <input type="number" id="lag_factor" value="0.05" step="0.01">
                    <p class="text-[10px] text-gray-400 mt-1">Shift added to T_peak_min (0.7s)</p>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div class="input-group">
                        <label>Duration (s)</label>
                        <input type="number" id="t_end" value="2.0" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>Points (N)</label>
                        <input type="number" id="n_points" value="200" step="50">
                    </div>
                </div>
            </div>

            <!-- Section: Background & Bands -->
            <div>
                <h3 class="text-xs font-bold text-gray-900 border-b pb-1 mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-layer-group text-orange-500"></i> Env & Bands
                </h3>
                
                <div class="flex items-center gap-2 mb-2">
                    <input type="checkbox" id="include_bg" checked class="w-3 h-3 text-blue-600 rounded">
                    <span class="text-xs font-semibold text-gray-600">Background</span>
                </div>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div class="input-group">
                        <label>BG Norm</label>
                        <input type="number" id="bg_norm" value="10">
                    </div>
                    <div class="input-group">
                        <label>BG Index</label>
                        <input type="number" id="bg_index" value="-1.0" step="0.1">
                    </div>
                </div>

                <div class="input-group">
                    <label>Energy Bands (min,max | ...)</label>
                    <textarea id="bands_input" rows="4" class="font-mono text-xs">8,63 | 63,500 | 500,3970 | 3970,31260 | 31620,251000 | 251000,1000000</textarea>
                </div>
            </div>

            <!-- Section: System -->
            <div>
                <h3 class="text-xs font-bold text-gray-900 border-b pb-1 mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-sliders text-purple-500"></i> System
                </h3>
                <div class="flex items-center gap-2 mb-3 p-2 bg-gray-50 rounded border border-gray-100">
                    <input type="checkbox" id="noiseless" class="w-4 h-4 text-blue-600 rounded">
                    <label for="noiseless" class="cursor-pointer mb-0 select-none">Noiseless Mode</label>
                </div>
                <div class="input-group">
                    <label>Monte Carlo Iterations</label>
                    <input type="number" id="mc_iters" value="100" step="50" min="10" max="1000">
                </div>
            </div>
        </div>
    </aside>

    <!-- MAIN CONTENT -->
    <main class="flex-1 flex flex-col h-full overflow-hidden bg-gray-50">
        
        <!-- Navbar -->
        <nav class="bg-white border-b border-gray-200 px-6 flex items-center shadow-sm z-10">
            <button class="tab-btn active px-4 py-4 text-sm font-medium text-gray-600 hover:text-blue-600 focus:outline-none transition-colors" onclick="switchTab('single', this)">
                <i class="fa-solid fa-chart-line mr-2"></i>Single Run Analysis
            </button>
            <button class="tab-btn px-4 py-4 text-sm font-medium text-gray-600 hover:text-blue-600 focus:outline-none transition-colors" onclick="switchTab('mc', this)">
                <i class="fa-solid fa-dice mr-2"></i>Monte Carlo Verification
            </button>
        </nav>

        <!-- Scrollable Area -->
        <div class="flex-1 overflow-y-auto p-6 scroll-smooth">
            
            <!-- VIEW: SINGLE RUN -->
            <div id="view-single" class="space-y-6 max-w-7xl mx-auto">
                
                <!-- Action Bar -->
                <div class="flex justify-between items-center bg-white p-4 rounded-lg shadow-sm border border-gray-100">
                    <div>
                        <h2 class="text-lg font-bold text-gray-800">Single Simulation</h2>
                        <p class="text-sm text-gray-500">Simulate one GRB event and analyze deviations.</p>
                    </div>
                    <button onclick="runSingleSimulation()" class="btn bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded shadow-md flex items-center gap-2">
                        <i class="fa-solid fa-play"></i> Run Simulation
                    </button>
                </div>

                <!-- Plot: Light Curves -->
                <div class="bg-white p-1 rounded-lg shadow-sm border border-gray-100">
                    <div id="plot_lc" class="w-full h-[400px]"></div>
                </div>

                <!-- Histograms Row -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-100">
                        <h3 class="font-bold text-gray-700 mb-2 text-sm uppercase">Numeric Error Distribution</h3>
                        <p class="text-xs text-gray-400 mb-4">Normalized Error = (Actual - Predicted) / Mean</p>
                        <div id="plot_num_hist" class="w-full h-[350px]"></div>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-100">
                        <h3 class="font-bold text-gray-700 mb-2 text-sm uppercase">Sign Bias Distribution</h3>
                        <p class="text-xs text-gray-400 mb-4">Count of time bins where signal was Brighter/Dimmer than ref.</p>
                        <div id="plot_sign_hist" class="w-full h-[350px]"></div>
                    </div>
                </div>

                <!-- Autocorrelation -->
                <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-100 mb-10">
                    <h3 class="font-bold text-gray-700 mb-2 text-sm uppercase">Autocorrelation of Deviations</h3>
                    <p class="text-xs text-gray-400 mb-4">Detects if errors are correlated in time (indicating a lag or model mismatch).</p>
                    <div id="plot_autocorr" class="w-full h-[400px]"></div>
                </div>
            </div>

            <!-- VIEW: MONTE CARLO -->
            <div id="view-mc" class="hidden space-y-6 max-w-7xl mx-auto">
                
                <!-- Action Bar -->
                <div class="flex justify-between items-center bg-white p-4 rounded-lg shadow-sm border border-gray-100">
                    <div>
                        <h2 class="text-lg font-bold text-gray-800">Monte Carlo Verification</h2>
                        <p class="text-sm text-gray-500">Run many iterations to find systematic bias in autocorrelation.</p>
                    </div>
                    <div class="flex items-center gap-4">
                        <div id="mc-status" class="text-sm font-mono text-gray-500 hidden">
                            <span class="loader mr-2"></span> <span id="mc-iter-count">0/100</span>
                        </div>
                        <button onclick="runMonteCarlo()" id="btn-mc" class="btn bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded shadow-md flex items-center gap-2">
                            <i class="fa-solid fa-rotate"></i> Run Monte Carlo
                        </button>
                    </div>
                </div>

                <!-- MC Plot -->
                <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-100">
                    <h3 class="font-bold text-gray-700 mb-2 text-sm uppercase">Mean Autocorrelation vs. Energy</h3>
                    <p class="text-xs text-gray-400 mb-4">Aggregated results (Mean Â± Std Dev) across all iterations.</p>
                    <div id="plot_mc" class="w-full h-[550px]"></div>
                </div>
            </div>

        </div>
    </main>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        // --- CONSTANTS & HELPERS ---
        const AREA = 100.0; // cm^2
        
        function linspace(start, end, num) {
            const arr = [];
            const step = (end - start) / (num - 1);
            for (let i = 0; i < num; i++) arr.push(start + (step * i));
            return arr;
        }

        function logspace(startExp, endExp, num) {
            const arr = [];
            const step = (endExp - startExp) / (num - 1);
            for (let i = 0; i < num; i++) arr.push(Math.pow(10, startExp + (step * i)));
            return arr;
        }

        function randn_bm() {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        }

        function poisson(lambda) {
            if (lambda > 20) return Math.round(lambda + Math.sqrt(lambda) * randn_bm());
            let L = Math.exp(-lambda);
            let k = 0, p = 1;
            do { k++; p *= Math.random(); } while (p > L);
            return k - 1;
        }

        function trapz(y, x) {
            let sum = 0;
            for (let i = 0; i < x.length - 1; i++) {
                sum += 0.5 * (y[i+1] + y[i]) * (x[i+1] - x[i]);
            }
            return sum;
        }

        // --- PHYSICS MODELS ---
        
        function bandFunction(E, Ep, alpha, beta, E0, F0) {
            const E_break = (alpha - beta) * Ep;
            return E.map(val => {
                if (val <= E_break) return F0 * Math.pow(val/E0, alpha) * Math.exp(-val/Ep);
                else return F0 * Math.pow(E_break/E0, alpha - beta) * Math.exp(beta - alpha) * Math.pow(val/E0, beta);
            });
        }

        function powerLawCutoff(E, K_pl, E_pivot, gamma, E_cut) {
            return E.map(val => {
                const safeE = (val === 0) ? 1e-10 : val;
                return K_pl * Math.pow(safeE/E_pivot, -gamma) * Math.exp(-safeE/E_cut);
            });
        }

        // --- SIMULATION CORE ---

        function runStep() {
            // 1. Gather Params from UI
            // Band
            const alpha = parseFloat(document.getElementById('alpha').value);
            const beta = parseFloat(document.getElementById('beta').value);
            const ep = parseFloat(document.getElementById('e_peak').value);
            
            // Power Law
            const includePL = document.getElementById('include_pl').checked;
            const gamma = parseFloat(document.getElementById('gamma').value);
            const k_pl = parseFloat(document.getElementById('k_pl').value) * 1e-8; // Scaling factor from UI
            const e_cut = parseFloat(document.getElementById('e_cut').value);
            const e_pivot = 1000000.0; // 1000 MeV (10^6 keV)
            
            // Temporal
            const rise = parseFloat(document.getElementById('rise_index').value);
            const decay = parseFloat(document.getElementById('decay_index').value);
            const lagInput = parseFloat(document.getElementById('lag_factor').value);
            const tEnd = parseFloat(document.getElementById('t_end').value);
            const nPoints = parseInt(document.getElementById('n_points').value);
            
            // Background
            const includeBg = document.getElementById('include_bg').checked;
            const bgNorm = parseFloat(document.getElementById('bg_norm').value);
            const bgIndex = parseFloat(document.getElementById('bg_index').value);

            // System
            const noiseless = document.getElementById('noiseless').checked;
            
            // Bands parsing
            const bandsStr = document.getElementById('bands_input').value;
            const bands = [];
            try {
                bandsStr.split('|').forEach(part => {
                    const [min, max] = part.split(',').map(s => parseFloat(s.trim()));
                    if(!isNaN(min) && !isNaN(max)) bands.push([min, max]);
                });
            } catch(e) { console.error("Band parsing error"); }
            if(bands.length === 0) bands.push([50, 100]); // Fallback

            const tStart = 0.0;
            const timeGrid = linspace(tStart, tEnd, nPoints);
            const dt = (tEnd - tStart) / (nPoints - 1);

            // 2. Setup Energy Grid & Spectrum
            // Updated range to cover 1 GeV+ (1e6 keV)
            const E_grid = logspace(0, 6.5, 2000); // 1 keV to ~3.1 MeV
            
            const specBand = bandFunction(E_grid, ep, alpha, beta, 100, 1.0);
            let totalSpec = specBand;

            if (includePL) {
                const specPL = powerLawCutoff(E_grid, k_pl, e_pivot, gamma, e_cut);
                totalSpec = specBand.map((val, i) => val + specPL[i]);
            }

            // 3. Peak Time Calculation
            const bandCenters = bands.map(b => (b[0]+b[1])/2);
            const logCenters = bandCenters.map(v => Math.log10(v));
            const minLog = Math.min(...logCenters);
            const maxLog = Math.max(...logCenters);
            
            // Normalize log centers 0..1
            const norms = logCenters.map(l => (maxLog === minLog) ? 0 : (l - minLog) / (maxLog - minLog));

            const results = {}; 

            // 4. Loop Bands
            bands.forEach((band, idx) => {
                const [eMin, eMax] = band;
                
                // A. Integrate Flux
                const idxs = E_grid.map((e, i) => (e >= eMin && e <= eMax) ? i : -1).filter(i => i !== -1);
                
                let flux = 0;
                if(idxs.length > 1) {
                    const subE = idxs.map(i => E_grid[i]);
                    const subSpec = idxs.map(i => totalSpec[i]);
                    flux = trapz(subSpec, subE) * AREA;
                }

                // B. Temporal Profile
                // Base peak min is 0.7s
                const tPeakMin = 0.7;
                const tPeak = tPeakMin + norms[idx] * lagInput; 

                const profile = timeGrid.map(t => {
                    if (t < tPeak) {
                        return (tPeak > 0) ? Math.pow(t/tPeak, rise) : 0;
                    } else {
                        return (tPeak > 0) ? Math.pow(tPeak/t, decay) * Math.exp(-(t - tPeak)/tPeak) : 0;
                    }
                });

                // C. Background
                let bgRate = 0;
                if (includeBg) {
                    bgRate = bgNorm * Math.pow(bandCenters[idx], bgIndex);
                }

                // D. Generate Counts
                const counts = profile.map(p => {
                    const rate = (flux * p) + bgRate;
                    const expected = rate * dt;
                    return noiseless ? expected : poisson(expected);
                });

                results[`${eMin}-${eMax}`] = counts;
            });

            return { t: timeGrid, countsData: results, bandCenters, bands };
        }

        // --- ANALYSIS LOGIC ---

        function analyzeData(simResult) {
            const { countsData, bandCenters } = simResult;
            const keys = Object.keys(countsData);
            // Sort keys by energy to ensure Ref is lowest
            keys.sort((a,b) => parseFloat(a.split('-')[0]) - parseFloat(b.split('-')[0]));

            const refKey = keys[0];
            const refCounts = countsData[refKey];
            const meanRef = refCounts.reduce((a,b)=>a+b,0) / refCounts.length;

            const analysis = {
                numericErrors: {},
                signs: { labels: [], minus: [], zero: [], plus: [] },
                autocorr: { x: [], lags: [[], [], [], []] }
            };

            // Analyze Deviations for higher bands
            for(let i=1; i<keys.length; i++) {
                const key = keys[i];
                const tgtCounts = countsData[key];
                const meanTgt = tgtCounts.reduce((a,b)=>a+b,0) / tgtCounts.length;

                // 1. Predict based on Ref
                const pred = refCounts.map(r => (meanRef > 0) ? r * (meanTgt / meanRef) : 0);
                
                // 2. Deviations
                const errors = [];
                const signVec = [];
                
                for(let k=0; k<tgtCounts.length; k++) {
                    let diff = tgtCounts[k] - pred[k];
                    let normErr = (meanTgt > 0) ? diff / meanTgt : 0;
                    
                    errors.push(normErr);
                    
                    if(normErr > 0) signVec.push(1);
                    else if(normErr < 0) signVec.push(-1);
                    else signVec.push(0);
                }

                analysis.numericErrors[key] = errors;

                // 3. Sign Stats
                let m=0, z=0, p=0;
                signVec.forEach(s => { if(s===-1) m++; else if(s===0) z++; else p++; });
                analysis.signs.labels.push(key + " keV");
                analysis.signs.minus.push(m);
                analysis.signs.zero.push(z);
                analysis.signs.plus.push(p);

                // 4. Autocorrelation (Lag 1..4)
                analysis.autocorr.x.push(bandCenters[i]);
                for(let l=1; l<=4; l++) {
                    let sum = 0;
                    let n = 0;
                    for(let k=0; k < signVec.length - l; k++) {
                        sum += signVec[k] * signVec[k+l];
                        n++;
                    }
                    analysis.autocorr.lags[l-1].push( n>0 ? sum/n : 0 );
                }
            }
            return analysis;
        }

        // --- UI HANDLERS ---

        function runSingleSimulation() {
            try {
                const sim = runStep();
                const res = analyzeData(sim);

                // PLOT 1: Light Curves
                const lcData = [];
                Object.keys(sim.countsData).forEach(k => {
                    lcData.push({
                        x: sim.t,
                        y: sim.countsData[k],
                        name: k + " keV",
                        type: 'scatter',
                        mode: 'lines'
                    });
                });
                Plotly.newPlot('plot_lc', lcData, {
                    title: 'Light Curves',
                    xaxis: {title: 'Time (s)'},
                    yaxis: {title: 'Counts'},
                    margin: {t:30, l:40, r:20, b:40},
                    showlegend: true,
                    legend: {x: 1, y: 1}
                });

                // PLOT 2: Numeric Histograms
                const numHistData = [];
                Object.keys(res.numericErrors).forEach(k => {
                    numHistData.push({
                        x: res.numericErrors[k],
                        type: 'histogram',
                        opacity: 0.6,
                        name: k,
                        nbinsx: 50
                    });
                });
                Plotly.newPlot('plot_num_hist', numHistData, {
                    barmode: "overlay",
                    xaxis: {title: "Normalized Error"},
                    margin: {t:20, l:40, r:20, b:30},
                    showlegend: true
                });

                // PLOT 3: Sign Histograms
                const signData = [
                    { x: res.signs.labels, y: res.signs.minus, name: 'Dimmer (-)', type: 'bar', marker: {color: '#60a5fa'} },
                    { x: res.signs.labels, y: res.signs.zero, name: 'Same (0)', type: 'bar', marker: {color: '#d1d5db'} },
                    { x: res.signs.labels, y: res.signs.plus, name: 'Brighter (+)', type: 'bar', marker: {color: '#f87171'} }
                ];
                Plotly.newPlot('plot_sign_hist', signData, {
                    barmode: 'stack',
                    margin: {t:20, l:40, r:20, b:30},
                    showlegend: false
                });

                // PLOT 4: Autocorrelation
                const acData = [];
                const colors = ['#4f46e5', '#7c3aed', '#db2777', '#f472b6'];
                for(let i=0; i<4; i++) {
                    acData.push({
                        x: res.autocorr.x,
                        y: res.autocorr.lags[i],
                        mode: 'lines+markers',
                        name: `Lag ${i+1}`,
                        line: {color: colors[i]}
                    });
                }
                Plotly.newPlot('plot_autocorr', acData, {
                    xaxis: {type: 'log', title: 'Energy (keV)'},
                    yaxis: {title: 'Autocorrelation', range: [-1, 1]},
                    margin: {t:20, l:40, r:20, b:40}
                });

            } catch (e) {
                console.error(e);
                alert("Simulation error: " + e.message);
            }
        }

        async function runMonteCarlo() {
            const btn = document.getElementById('btn-mc');
            const status = document.getElementById('mc-status');
            const counter = document.getElementById('mc-iter-count');
            const iters = parseInt(document.getElementById('mc_iters').value);

            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            status.classList.remove('hidden');

            const simTest = runStep(); // Run once to get dimensions
            const nHigh = simTest.bands.length - 1;
            const nLags = 4;
            
            const sums = Array(nLags).fill(0).map(() => Array(nHigh).fill(0));
            const sqSums = Array(nLags).fill(0).map(() => Array(nHigh).fill(0));
            
            let energiesX = [];

            for(let i=0; i<iters; i++) {
                const sim = runStep();
                const res = analyzeData(sim);
                
                energiesX = res.autocorr.x;

                for(let l=0; l<nLags; l++) {
                    for(let b=0; b<nHigh; b++) {
                        const val = res.autocorr.lags[l][b];
                        sums[l][b] += val;
                        sqSums[l][b] += (val * val);
                    }
                }

                if(i % 5 === 0 || i === iters-1) {
                    counter.innerText = `${i+1}/${iters}`;
                    await new Promise(r => setTimeout(r, 0)); 
                }
            }

            const means = Array(nLags).fill(0).map(() => Array(nHigh).fill(0));
            const stds = Array(nLags).fill(0).map(() => Array(nHigh).fill(0));

            for(let l=0; l<nLags; l++) {
                for(let b=0; b<nHigh; b++) {
                    const mean = sums[l][b] / iters;
                    const variance = (sqSums[l][b] / iters) - (mean * mean);
                    means[l][b] = mean;
                    stds[l][b] = Math.sqrt(Math.max(0, variance));
                }
            }

            const traces = [];
            const colors = ['#4f46e5', '#7c3aed', '#db2777', '#f472b6'];
            
            for(let l=0; l<nLags; l++) {
                traces.push({
                    x: energiesX,
                    y: means[l],
                    error_y: {
                        type: 'data',
                        array: stds[l],
                        visible: true,
                        color: colors[l],
                        opacity: 0.4
                    },
                    mode: 'lines+markers',
                    name: `Lag ${l+1}`,
                    line: {color: colors[l]}
                });
            }

            Plotly.newPlot('plot_mc', traces, {
                title: `Monte Carlo Results (N=${iters})`,
                xaxis: {type: 'log', title: 'Energy (keV)'},
                yaxis: {title: 'Mean Autocorrelation', range: [-0.5, 0.5]},
                margin: {t:40, l:40, r:20, b:40}
            });

            btn.disabled = false;
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
            status.classList.add('hidden');
        }

        function switchTab(viewId, btnElement) {
            document.getElementById('view-single').classList.add('hidden');
            document.getElementById('view-mc').classList.add('hidden');
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('view-' + viewId).classList.remove('hidden');
            btnElement.classList.add('active');
        }

        document.addEventListener("DOMContentLoaded", () => {
            runSingleSimulation();
        });

    </script>
</body>
</html>